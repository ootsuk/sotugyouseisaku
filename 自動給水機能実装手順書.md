# 自動給水機能 詳細実装手順書
## すくすくミントちゃん - 自動給水制御システム

---

## 📋 概要
土壌水分センサーの値に基づいて自動で水やりを行う機能の詳細実装手順書

## 🎯 実装目標
- 土壌水分値159以下での自動給水判定
- 前回給水から12時間経過の確認
- リレーモジュールによる水ポンプ制御
- 安全機能（連続給水防止、水タンク空検知）
- 給水履歴の記録と通知

---

## 🛠️ 必要な環境

### ハードウェア
- Raspberry Pi 5
- リレーモジュール AE-G5V-DRV
- 水中ポンプ（12V DC）
- 外部電源（ポンプ用）
- 水タンク
- 配管・ホース

### ソフトウェア
- Python 3.11.x
- RPi.GPIO
- センサー制御システム（前回実装）
- LINE通知システム

---

## 🔧 実装手順

### Step 1: ハードウェア接続

#### 1.1 リレーモジュール接続
```python
# GPIOピン定義
GPIO_PINS = {
    'RELAY_PUMP': 16,    # GPIO 16 (Pin 36) - ポンプ制御
    'RELAY_LED': 20,     # GPIO 20 (Pin 38) - LED制御（将来用）
}
```

#### 1.2 配線図
```
リレーモジュール AE-G5V-DRV:
- VCC → 5V (Pin 2)
- GND → GND (Pin 6)
- IN1 → GPIO 16 (Pin 36) - ポンプ制御
- IN2 → GPIO 20 (Pin 38) - LED制御（将来用）

水中ポンプ:
- 正極 → リレーモジュール NO1
- 負極 → リレーモジュール COM1
- 電源 → 外部12V電源

外部電源:
- 12V電源アダプター
- リレーモジュール VCC/GND接続
```

#### 1.3 安全回路
```
安全機能:
1. フロートスイッチによる水タンク空検知
2. 連続給水回数制限（最大2回）
3. 給水時間制限（最大5秒）
4. 緊急停止機能
```

### Step 2: 給水制御クラス実装

#### 2.1 給水制御クラス
```python
# src/watering/watering_controller.py
import RPi.GPIO as GPIO
import time
import logging
import json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from pathlib import Path

class WateringController:
    """自動給水制御クラス"""
    
    def __init__(self, relay_pin: int = 16):
        self.relay_pin = relay_pin
        self.logger = logging.getLogger("watering_controller")
        
        # 給水設定
        self.soil_moisture_threshold = 159  # 給水閾値
        self.watering_interval_hours = 12   # 給水間隔（時間）
        self.watering_duration_seconds = 5  # 給水時間（秒）
        self.max_consecutive_waterings = 2  # 最大連続給水回数
        self.water_amount_ml = 100          # 給水量（ml）
        
        # 状態管理
        self.last_watering_time = None
        self.consecutive_watering_count = 0
        self.is_watering = False
        self.watering_history = []
        
        # ファイルパス
        self.data_dir = Path("/mnt/usb-storage/watering_data")
        self.data_dir.mkdir(exist_ok=True)
        self.history_file = self.data_dir / "watering_history.json"
        
        # GPIO初期化
        self._initialize_gpio()
        
        # 履歴読み込み
        self._load_watering_history()
    
    def _initialize_gpio(self):
        """GPIO初期化"""
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.relay_pin, GPIO.OUT)
            GPIO.output(self.relay_pin, GPIO.HIGH)  # リレーOFF（HIGHでOFF）
            self.logger.info("GPIO初期化完了")
        except Exception as e:
            self.logger.error(f"GPIO初期化エラー: {str(e)}")
            raise
    
    def _load_watering_history(self):
        """給水履歴を読み込み"""
        try:
            if self.history_file.exists():
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    history_data = json.load(f)
                    self.watering_history = history_data.get('history', [])
                    if self.watering_history:
                        last_record = self.watering_history[-1]
                        self.last_watering_time = datetime.fromisoformat(
                            last_record['timestamp']
                        )
                        self.consecutive_watering_count = last_record.get(
                            'consecutive_count', 0
                        )
                self.logger.info(f"給水履歴読み込み完了: {len(self.watering_history)}件")
        except Exception as e:
            self.logger.error(f"給水履歴読み込みエラー: {str(e)}")
            self.watering_history = []
    
    def _save_watering_history(self):
        """給水履歴を保存"""
        try:
            history_data = {
                'last_updated': datetime.now().isoformat(),
                'history': self.watering_history[-100:]  # 最新100件のみ保存
            }
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(history_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"給水履歴保存エラー: {str(e)}")
    
    def _can_water(self, soil_moisture: float, water_available: bool) -> Dict[str, Any]:
        """給水可能かチェック"""
        checks = {
            'soil_moisture_ok': soil_moisture <= self.soil_moisture_threshold,
            'water_available': water_available,
            'interval_ok': True,
            'consecutive_limit_ok': self.consecutive_watering_count < self.max_consecutive_waterings,
            'not_currently_watering': not self.is_watering
        }
        
        # 給水間隔チェック
        if self.last_watering_time:
            time_since_last = datetime.now() - self.last_watering_time
            checks['interval_ok'] = time_since_last >= timedelta(hours=self.watering_interval_hours)
        
        can_water = all(checks.values())
        
        return {
            'can_water': can_water,
            'checks': checks,
            'time_since_last': str(time_since_last) if self.last_watering_time else None
        }
    
    def start_watering(self, soil_moisture: float, water_available: bool) -> Dict[str, Any]:
        """給水開始"""
        if self.is_watering:
            return {
                'success': False,
                'message': '既に給水中です',
                'error': 'ALREADY_WATERING'
            }
        
        # 給水可能かチェック
        check_result = self._can_water(soil_moisture, water_available)
        if not check_result['can_water']:
            return {
                'success': False,
                'message': '給水条件を満たしていません',
                'error': 'CONDITIONS_NOT_MET',
                'checks': check_result['checks']
            }
        
        try:
            self.is_watering = True
            self.logger.info("給水開始")
            
            # リレーON（LOWでON）
            GPIO.output(self.relay_pin, GPIO.LOW)
            
            # 給水時間待機
            time.sleep(self.watering_duration_seconds)
            
            # リレーOFF
            GPIO.output(self.relay_pin, GPIO.HIGH)
            
            # 状態更新
            self.last_watering_time = datetime.now()
            self.consecutive_watering_count += 1
            
            # 履歴記録
            watering_record = {
                'timestamp': self.last_watering_time.isoformat(),
                'soil_moisture': soil_moisture,
                'duration_seconds': self.watering_duration_seconds,
                'water_amount_ml': self.water_amount_ml,
                'consecutive_count': self.consecutive_watering_count,
                'success': True
            }
            self.watering_history.append(watering_record)
            self._save_watering_history()
            
            self.logger.info(f"給水完了: {self.water_amount_ml}ml")
            
            return {
                'success': True,
                'message': f'給水完了: {self.water_amount_ml}ml',
                'watering_record': watering_record
            }
            
        except Exception as e:
            self.logger.error(f"給水エラー: {str(e)}")
            
            # リレーOFF（安全のため）
            GPIO.output(self.relay_pin, GPIO.HIGH)
            
            # エラー履歴記録
            error_record = {
                'timestamp': datetime.now().isoformat(),
                'soil_moisture': soil_moisture,
                'error': str(e),
                'success': False
            }
            self.watering_history.append(error_record)
            self._save_watering_history()
            
            return {
                'success': False,
                'message': f'給水エラー: {str(e)}',
                'error': 'WATERING_ERROR'
            }
        
        finally:
            self.is_watering = False
    
    def stop_watering(self) -> Dict[str, Any]:
        """給水強制停止"""
        try:
            if self.is_watering:
                GPIO.output(self.relay_pin, GPIO.HIGH)
                self.is_watering = False
                self.logger.info("給水強制停止")
                return {'success': True, 'message': '給水停止完了'}
            else:
                return {'success': False, 'message': '給水中ではありません'}
        except Exception as e:
            self.logger.error(f"給水停止エラー: {str(e)}")
            return {'success': False, 'message': f'停止エラー: {str(e)}'}
    
    def reset_consecutive_count(self):
        """連続給水カウントリセット"""
        self.consecutive_watering_count = 0
        self.logger.info("連続給水カウントリセット")
    
    def get_status(self) -> Dict[str, Any]:
        """給水システム状態取得"""
        return {
            'is_watering': self.is_watering,
            'last_watering_time': self.last_watering_time.isoformat() if self.last_watering_time else None,
            'consecutive_watering_count': self.consecutive_watering_count,
            'max_consecutive_waterings': self.max_consecutive_waterings,
            'soil_moisture_threshold': self.soil_moisture_threshold,
            'watering_interval_hours': self.watering_interval_hours,
            'watering_duration_seconds': self.watering_duration_seconds,
            'water_amount_ml': self.water_amount_ml,
            'history_count': len(self.watering_history)
        }
    
    def get_recent_history(self, count: int = 10) -> List[Dict[str, Any]]:
        """最近の給水履歴取得"""
        return self.watering_history[-count:] if self.watering_history else []
    
    def cleanup(self):
        """リソースクリーンアップ"""
        try:
            GPIO.output(self.relay_pin, GPIO.HIGH)  # リレーOFF
            GPIO.cleanup()
            self.logger.info("GPIOクリーンアップ完了")
        except Exception as e:
            self.logger.error(f"クリーンアップエラー: {str(e)}")
```

### Step 3: 自動給水マネージャー

#### 3.1 自動給水管理システム
```python
# src/watering/auto_watering_manager.py
import threading
import time
import logging
from datetime import datetime
from typing import Dict, Any
from .watering_controller import WateringController
from ..sensors.sensor_manager import SensorManager
from ..notifications.line_notify import LineNotify

class AutoWateringManager:
    """自動給水管理クラス"""
    
    def __init__(self, sensor_manager: SensorManager, line_notify: LineNotify):
        self.sensor_manager = sensor_manager
        self.line_notify = line_notify
        self.watering_controller = WateringController()
        self.logger = logging.getLogger("auto_watering_manager")
        
        self.running = False
        self.monitor_thread = None
        self.check_interval = 60  # 1分間隔でチェック
        
    def start_auto_watering(self):
        """自動給水開始"""
        if self.running:
            self.logger.warning("自動給水は既に実行中です")
            return
        
        self.running = True
        self.monitor_thread = threading.Thread(
            target=self._monitor_and_water,
            daemon=True
        )
        self.monitor_thread.start()
        self.logger.info("自動給水監視開始")
    
    def stop_auto_watering(self):
        """自動給水停止"""
        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        self.logger.info("自動給水監視停止")
    
    def _monitor_and_water(self):
        """給水監視と実行"""
        while self.running:
            try:
                # センサーデータ取得
                sensor_data = self.sensor_manager.get_latest_data()
                
                # 土壌水分データ確認
                soil_moisture_data = sensor_data.get('soil_moisture', {})
                if 'error' in soil_moisture_data:
                    self.logger.error(f"土壌水分センサーエラー: {soil_moisture_data['error']}")
                    time.sleep(self.check_interval)
                    continue
                
                soil_moisture = soil_moisture_data.get('moisture_percentage', 0)
                
                # 水位データ確認
                water_level_data = sensor_data.get('water_level', {})
                if 'error' in water_level_data:
                    self.logger.error(f"フロートスイッチエラー: {water_level_data['error']}")
                    time.sleep(self.check_interval)
                    continue
                
                water_available = water_level_data.get('is_water_available', False)
                
                # 給水判定
                if soil_moisture <= self.watering_controller.soil_moisture_threshold:
                    self.logger.info(f"土壌水分低下検知: {soil_moisture}%")
                    
                    # 給水実行
                    result = self.watering_controller.start_watering(
                        soil_moisture, water_available
                    )
                    
                    if result['success']:
                        # 給水成功通知
                        self.line_notify.send_watering_notification(
                            self.watering_controller.water_amount_ml
                        )
                        self.logger.info("給水完了通知送信")
                    else:
                        # 給水失敗通知
                        error_msg = result.get('message', '不明なエラー')
                        self.line_notify.send_system_error(f"給水失敗: {error_msg}")
                        self.logger.error(f"給水失敗: {error_msg}")
                
                # 水タンク空警告
                if not water_available:
                    self.logger.warning("水タンク空警告")
                    self.line_notify.send_water_tank_empty()
                
                time.sleep(self.check_interval)
                
            except Exception as e:
                self.logger.error(f"自動給水監視エラー: {str(e)}")
                time.sleep(30)  # エラー時は30秒待機
    
    def manual_watering(self) -> Dict[str, Any]:
        """手動給水実行"""
        try:
            # 現在のセンサーデータ取得
            sensor_data = self.sensor_manager.get_latest_data()
            soil_moisture = sensor_data.get('soil_moisture', {}).get('moisture_percentage', 0)
            water_available = sensor_data.get('water_level', {}).get('is_water_available', True)
            
            # 手動給水実行
            result = self.watering_controller.start_watering(soil_moisture, water_available)
            
            if result['success']:
                # 手動給水完了通知
                self.line_notify.send_message(
                    f"🌱 手動給水完了！\n"
                    f"💧 給水量: {self.watering_controller.water_amount_ml}ml\n"
                    f"⏰ 時刻: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                )
            
            return result
            
        except Exception as e:
            self.logger.error(f"手動給水エラー: {str(e)}")
            return {
                'success': False,
                'message': f'手動給水エラー: {str(e)}',
                'error': 'MANUAL_WATERING_ERROR'
            }
    
    def emergency_stop(self) -> Dict[str, Any]:
        """緊急停止"""
        try:
            result = self.watering_controller.stop_watering()
            
            # 緊急停止通知
            self.line_notify.send_message(
                f"🚨 緊急停止実行！\n"
                f"⏰ 時刻: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"システムを確認してください"
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"緊急停止エラー: {str(e)}")
            return {
                'success': False,
                'message': f'緊急停止エラー: {str(e)}',
                'error': 'EMERGENCY_STOP_ERROR'
            }
    
    def get_watering_status(self) -> Dict[str, Any]:
        """給水システム状態取得"""
        return {
            'auto_watering_running': self.running,
            'watering_controller_status': self.watering_controller.get_status(),
            'recent_history': self.watering_controller.get_recent_history(5)
        }
    
    def update_settings(self, settings: Dict[str, Any]) -> Dict[str, Any]:
        """給水設定更新"""
        try:
            if 'soil_moisture_threshold' in settings:
                self.watering_controller.soil_moisture_threshold = settings['soil_moisture_threshold']
            
            if 'watering_interval_hours' in settings:
                self.watering_controller.watering_interval_hours = settings['watering_interval_hours']
            
            if 'watering_duration_seconds' in settings:
                self.watering_controller.watering_duration_seconds = settings['watering_duration_seconds']
            
            if 'water_amount_ml' in settings:
                self.watering_controller.water_amount_ml = settings['water_amount_ml']
            
            self.logger.info(f"給水設定更新: {settings}")
            return {'success': True, 'message': '設定更新完了'}
            
        except Exception as e:
            self.logger.error(f"設定更新エラー: {str(e)}")
            return {'success': False, 'message': f'設定更新エラー: {str(e)}'}
```

### Step 4: Flask統合

#### 4.1 Web API実装
```python
# src/api/watering_api.py
from flask import Blueprint, request, jsonify
import logging
from ..watering.auto_watering_manager import AutoWateringManager

watering_bp = Blueprint('watering', __name__)
logger = logging.getLogger("watering_api")

# グローバル変数（実際の実装では適切に管理）
auto_watering_manager = None

def init_watering_api(sensor_manager, line_notify):
    """給水API初期化"""
    global auto_watering_manager
    auto_watering_manager = AutoWateringManager(sensor_manager, line_notify)

@watering_bp.route('/watering/status', methods=['GET'])
def get_watering_status():
    """給水システム状態取得"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': '給水システムが初期化されていません'}), 500
        
        status = auto_watering_manager.get_watering_status()
        return jsonify(status)
    except Exception as e:
        logger.error(f"給水状態取得エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/manual', methods=['POST'])
def manual_watering():
    """手動給水実行"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': '給水システムが初期化されていません'}), 500
        
        result = auto_watering_manager.manual_watering()
        return jsonify(result)
    except Exception as e:
        logger.error(f"手動給水エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/emergency_stop', methods=['POST'])
def emergency_stop():
    """緊急停止"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': '給水システムが初期化されていません'}), 500
        
        result = auto_watering_manager.emergency_stop()
        return jsonify(result)
    except Exception as e:
        logger.error(f"緊急停止エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/settings', methods=['GET', 'POST'])
def watering_settings():
    """給水設定取得・更新"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': '給水システムが初期化されていません'}), 500
        
        if request.method == 'GET':
            # 設定取得
            status = auto_watering_manager.get_watering_status()
            settings = {
                'soil_moisture_threshold': status['watering_controller_status']['soil_moisture_threshold'],
                'watering_interval_hours': status['watering_controller_status']['watering_interval_hours'],
                'watering_duration_seconds': status['watering_controller_status']['watering_duration_seconds'],
                'water_amount_ml': status['watering_controller_status']['water_amount_ml']
            }
            return jsonify(settings)
        
        elif request.method == 'POST':
            # 設定更新
            settings = request.get_json()
            result = auto_watering_manager.update_settings(settings)
            return jsonify(result)
    
    except Exception as e:
        logger.error(f"給水設定エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/history', methods=['GET'])
def get_watering_history():
    """給水履歴取得"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': '給水システムが初期化されていません'}), 500
        
        count = request.args.get('count', 10, type=int)
        history = auto_watering_manager.watering_controller.get_recent_history(count)
        return jsonify({'history': history})
    except Exception as e:
        logger.error(f"給水履歴取得エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500
```

### Step 5: テスト実装

#### 5.1 給水システムテスト
```python
# test_watering.py
import time
import logging
from src.sensors.sensor_manager import SensorManager
from src.notifications.line_notify import LineNotify
from src.watering.auto_watering_manager import AutoWateringManager

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

def test_watering_system():
    """給水システムテスト"""
    print("💧 給水システムテスト開始")
    
    # センサーマネージャー初期化
    sensor_manager = SensorManager()
    
    # LINE通知初期化（テスト用）
    line_notify = LineNotify()
    
    # 自動給水マネージャー初期化
    auto_watering_manager = AutoWateringManager(sensor_manager, line_notify)
    
    # 給水システム状態確認
    print("\n📊 給水システム状態")
    status = auto_watering_manager.get_watering_status()
    print(f"状態: {status}")
    
    # 手動給水テスト
    print("\n🌱 手動給水テスト")
    result = auto_watering_manager.manual_watering()
    print(f"結果: {result}")
    
    # 設定更新テスト
    print("\n⚙️ 設定更新テスト")
    new_settings = {
        'soil_moisture_threshold': 150,
        'watering_duration_seconds': 3
    }
    update_result = auto_watering_manager.update_settings(new_settings)
    print(f"更新結果: {update_result}")
    
    # 自動給水テスト（30秒間）
    print("\n🔄 自動給水テスト (30秒間)")
    auto_watering_manager.start_auto_watering()
    
    for i in range(6):
        time.sleep(5)
        current_status = auto_watering_manager.get_watering_status()
        print(f"5秒後: 自動給水実行中={current_status['auto_watering_running']}")
    
    auto_watering_manager.stop_auto_watering()
    
    # 給水履歴確認
    print("\n📋 給水履歴")
    history = auto_watering_manager.watering_controller.get_recent_history(5)
    for record in history:
        print(f"履歴: {record}")
    
    print("✅ 給水システムテスト完了")

if __name__ == "__main__":
    test_watering_system()
```

### Step 6: トラブルシューティング

#### 6.1 よくある問題と解決方法

**リレーが動作しない:**
```bash
# GPIO状態確認
gpio read 16

# 期待される値: 1 (OFF状態)
```

**ポンプが動作しない:**
```bash
# 電源確認
# 12V電源アダプターの動作確認
# ポンプの接続確認
```

**給水が実行されない:**
```bash
# センサーデータ確認
python test_sensors.py

# 給水条件確認
# - 土壌水分値 <= 159
# - 前回給水から12時間経過
# - 水タンクに水がある
```

#### 6.2 デバッグ用コマンド
```bash
# 給水システムテスト
cd /home/pi/smart-planter
python test_watering.py

# 給水履歴確認
cat /mnt/usb-storage/watering_data/watering_history.json

# GPIO状態確認
gpio readall
```

---

## 📊 実装完了チェックリスト

- [ ] ハードウェア接続完了
- [ ] リレーモジュール接続完了
- [ ] 給水制御クラス実装完了
- [ ] 自動給水マネージャー実装完了
- [ ] Web API実装完了
- [ ] テストスクリプト実行完了
- [ ] 安全機能確認完了
- [ ] 給水履歴機能確認完了
- [ ] LINE通知統合完了
- [ ] エラーハンドリング確認完了

---

## 🎯 次のステップ

1. **Web UI実装**: 給水制御のWebインターフェース
2. **データ可視化**: 給水履歴のグラフ表示
3. **設定画面**: 給水パラメータの動的変更
4. **統合テスト**: 全システムの動作確認

---

**作成日**: 2025年1月
**バージョン**: 1.0
**チーム**: KEBABS

