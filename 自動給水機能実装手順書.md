# è‡ªå‹•çµ¦æ°´æ©Ÿèƒ½ è©³ç´°å®Ÿè£…æ‰‹é †æ›¸
## ã™ãã™ããƒŸãƒ³ãƒˆã¡ã‚ƒã‚“ - è‡ªå‹•çµ¦æ°´åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ 

---

## ğŸ“‹ æ¦‚è¦
åœŸå£Œæ°´åˆ†ã‚»ãƒ³ã‚µãƒ¼ã®å€¤ã«åŸºã¥ã„ã¦è‡ªå‹•ã§æ°´ã‚„ã‚Šã‚’è¡Œã†æ©Ÿèƒ½ã®è©³ç´°å®Ÿè£…æ‰‹é †æ›¸

## ğŸ¯ å®Ÿè£…ç›®æ¨™
- åœŸå£Œæ°´åˆ†å€¤159ä»¥ä¸‹ã§ã®è‡ªå‹•çµ¦æ°´åˆ¤å®š
- å‰å›çµ¦æ°´ã‹ã‚‰12æ™‚é–“çµŒéã®ç¢ºèª
- ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ˆã‚‹æ°´ãƒãƒ³ãƒ—åˆ¶å¾¡
- å®‰å…¨æ©Ÿèƒ½ï¼ˆé€£ç¶šçµ¦æ°´é˜²æ­¢ã€æ°´ã‚¿ãƒ³ã‚¯ç©ºæ¤œçŸ¥ï¼‰
- çµ¦æ°´å±¥æ­´ã®è¨˜éŒ²ã¨é€šçŸ¥

---

## ğŸ› ï¸ å¿…è¦ãªç’°å¢ƒ

### ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢
- Raspberry Pi 5
- ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« AE-G5V-DRV
- æ°´ä¸­ãƒãƒ³ãƒ—ï¼ˆ12V DCï¼‰
- å¤–éƒ¨é›»æºï¼ˆãƒãƒ³ãƒ—ç”¨ï¼‰
- æ°´ã‚¿ãƒ³ã‚¯
- é…ç®¡ãƒ»ãƒ›ãƒ¼ã‚¹

### ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢
- Python 3.11.x
- RPi.GPIO
- ã‚»ãƒ³ã‚µãƒ¼åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå‰å›å®Ÿè£…ï¼‰
- LINEé€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

---

## ğŸ”§ å®Ÿè£…æ‰‹é †

### Step 1: ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢æ¥ç¶š

#### 1.1 ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¥ç¶š
```python
# GPIOãƒ”ãƒ³å®šç¾©
GPIO_PINS = {
    'RELAY_PUMP': 16,    # GPIO 16 (Pin 36) - ãƒãƒ³ãƒ—åˆ¶å¾¡
    'RELAY_LED': 20,     # GPIO 20 (Pin 38) - LEDåˆ¶å¾¡ï¼ˆå°†æ¥ç”¨ï¼‰
}
```

#### 1.2 é…ç·šå›³
```
ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« AE-G5V-DRV:
- VCC â†’ 5V (Pin 2)
- GND â†’ GND (Pin 6)
- IN1 â†’ GPIO 16 (Pin 36) - ãƒãƒ³ãƒ—åˆ¶å¾¡
- IN2 â†’ GPIO 20 (Pin 38) - LEDåˆ¶å¾¡ï¼ˆå°†æ¥ç”¨ï¼‰

æ°´ä¸­ãƒãƒ³ãƒ—:
- æ­£æ¥µ â†’ ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« NO1
- è² æ¥µ â†’ ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« COM1
- é›»æº â†’ å¤–éƒ¨12Vé›»æº

å¤–éƒ¨é›»æº:
- 12Vé›»æºã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼
- ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« VCC/GNDæ¥ç¶š
```

#### 1.3 å®‰å…¨å›è·¯
```
å®‰å…¨æ©Ÿèƒ½:
1. ãƒ•ãƒ­ãƒ¼ãƒˆã‚¹ã‚¤ãƒƒãƒã«ã‚ˆã‚‹æ°´ã‚¿ãƒ³ã‚¯ç©ºæ¤œçŸ¥
2. é€£ç¶šçµ¦æ°´å›æ•°åˆ¶é™ï¼ˆæœ€å¤§2å›ï¼‰
3. çµ¦æ°´æ™‚é–“åˆ¶é™ï¼ˆæœ€å¤§5ç§’ï¼‰
4. ç·Šæ€¥åœæ­¢æ©Ÿèƒ½
```

### Step 2: çµ¦æ°´åˆ¶å¾¡ã‚¯ãƒ©ã‚¹å®Ÿè£…

#### 2.1 çµ¦æ°´åˆ¶å¾¡ã‚¯ãƒ©ã‚¹
```python
# src/watering/watering_controller.py
import RPi.GPIO as GPIO
import time
import logging
import json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from pathlib import Path

class WateringController:
    """è‡ªå‹•çµ¦æ°´åˆ¶å¾¡ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, relay_pin: int = 16):
        self.relay_pin = relay_pin
        self.logger = logging.getLogger("watering_controller")
        
        # çµ¦æ°´è¨­å®š
        self.soil_moisture_threshold = 159  # çµ¦æ°´é–¾å€¤
        self.watering_interval_hours = 12   # çµ¦æ°´é–“éš”ï¼ˆæ™‚é–“ï¼‰
        self.watering_duration_seconds = 5  # çµ¦æ°´æ™‚é–“ï¼ˆç§’ï¼‰
        self.max_consecutive_waterings = 2  # æœ€å¤§é€£ç¶šçµ¦æ°´å›æ•°
        self.water_amount_ml = 100          # çµ¦æ°´é‡ï¼ˆmlï¼‰
        
        # çŠ¶æ…‹ç®¡ç†
        self.last_watering_time = None
        self.consecutive_watering_count = 0
        self.is_watering = False
        self.watering_history = []
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        self.data_dir = Path("/mnt/usb-storage/watering_data")
        self.data_dir.mkdir(exist_ok=True)
        self.history_file = self.data_dir / "watering_history.json"
        
        # GPIOåˆæœŸåŒ–
        self._initialize_gpio()
        
        # å±¥æ­´èª­ã¿è¾¼ã¿
        self._load_watering_history()
    
    def _initialize_gpio(self):
        """GPIOåˆæœŸåŒ–"""
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.relay_pin, GPIO.OUT)
            GPIO.output(self.relay_pin, GPIO.HIGH)  # ãƒªãƒ¬ãƒ¼OFFï¼ˆHIGHã§OFFï¼‰
            self.logger.info("GPIOåˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            self.logger.error(f"GPIOåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {str(e)}")
            raise
    
    def _load_watering_history(self):
        """çµ¦æ°´å±¥æ­´ã‚’èª­ã¿è¾¼ã¿"""
        try:
            if self.history_file.exists():
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    history_data = json.load(f)
                    self.watering_history = history_data.get('history', [])
                    if self.watering_history:
                        last_record = self.watering_history[-1]
                        self.last_watering_time = datetime.fromisoformat(
                            last_record['timestamp']
                        )
                        self.consecutive_watering_count = last_record.get(
                            'consecutive_count', 0
                        )
                self.logger.info(f"çµ¦æ°´å±¥æ­´èª­ã¿è¾¼ã¿å®Œäº†: {len(self.watering_history)}ä»¶")
        except Exception as e:
            self.logger.error(f"çµ¦æ°´å±¥æ­´èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {str(e)}")
            self.watering_history = []
    
    def _save_watering_history(self):
        """çµ¦æ°´å±¥æ­´ã‚’ä¿å­˜"""
        try:
            history_data = {
                'last_updated': datetime.now().isoformat(),
                'history': self.watering_history[-100:]  # æœ€æ–°100ä»¶ã®ã¿ä¿å­˜
            }
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(history_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"çµ¦æ°´å±¥æ­´ä¿å­˜ã‚¨ãƒ©ãƒ¼: {str(e)}")
    
    def _can_water(self, soil_moisture: float, water_available: bool) -> Dict[str, Any]:
        """çµ¦æ°´å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯"""
        checks = {
            'soil_moisture_ok': soil_moisture <= self.soil_moisture_threshold,
            'water_available': water_available,
            'interval_ok': True,
            'consecutive_limit_ok': self.consecutive_watering_count < self.max_consecutive_waterings,
            'not_currently_watering': not self.is_watering
        }
        
        # çµ¦æ°´é–“éš”ãƒã‚§ãƒƒã‚¯
        if self.last_watering_time:
            time_since_last = datetime.now() - self.last_watering_time
            checks['interval_ok'] = time_since_last >= timedelta(hours=self.watering_interval_hours)
        
        can_water = all(checks.values())
        
        return {
            'can_water': can_water,
            'checks': checks,
            'time_since_last': str(time_since_last) if self.last_watering_time else None
        }
    
    def start_watering(self, soil_moisture: float, water_available: bool) -> Dict[str, Any]:
        """çµ¦æ°´é–‹å§‹"""
        if self.is_watering:
            return {
                'success': False,
                'message': 'æ—¢ã«çµ¦æ°´ä¸­ã§ã™',
                'error': 'ALREADY_WATERING'
            }
        
        # çµ¦æ°´å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
        check_result = self._can_water(soil_moisture, water_available)
        if not check_result['can_water']:
            return {
                'success': False,
                'message': 'çµ¦æ°´æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“',
                'error': 'CONDITIONS_NOT_MET',
                'checks': check_result['checks']
            }
        
        try:
            self.is_watering = True
            self.logger.info("çµ¦æ°´é–‹å§‹")
            
            # ãƒªãƒ¬ãƒ¼ONï¼ˆLOWã§ONï¼‰
            GPIO.output(self.relay_pin, GPIO.LOW)
            
            # çµ¦æ°´æ™‚é–“å¾…æ©Ÿ
            time.sleep(self.watering_duration_seconds)
            
            # ãƒªãƒ¬ãƒ¼OFF
            GPIO.output(self.relay_pin, GPIO.HIGH)
            
            # çŠ¶æ…‹æ›´æ–°
            self.last_watering_time = datetime.now()
            self.consecutive_watering_count += 1
            
            # å±¥æ­´è¨˜éŒ²
            watering_record = {
                'timestamp': self.last_watering_time.isoformat(),
                'soil_moisture': soil_moisture,
                'duration_seconds': self.watering_duration_seconds,
                'water_amount_ml': self.water_amount_ml,
                'consecutive_count': self.consecutive_watering_count,
                'success': True
            }
            self.watering_history.append(watering_record)
            self._save_watering_history()
            
            self.logger.info(f"çµ¦æ°´å®Œäº†: {self.water_amount_ml}ml")
            
            return {
                'success': True,
                'message': f'çµ¦æ°´å®Œäº†: {self.water_amount_ml}ml',
                'watering_record': watering_record
            }
            
        except Exception as e:
            self.logger.error(f"çµ¦æ°´ã‚¨ãƒ©ãƒ¼: {str(e)}")
            
            # ãƒªãƒ¬ãƒ¼OFFï¼ˆå®‰å…¨ã®ãŸã‚ï¼‰
            GPIO.output(self.relay_pin, GPIO.HIGH)
            
            # ã‚¨ãƒ©ãƒ¼å±¥æ­´è¨˜éŒ²
            error_record = {
                'timestamp': datetime.now().isoformat(),
                'soil_moisture': soil_moisture,
                'error': str(e),
                'success': False
            }
            self.watering_history.append(error_record)
            self._save_watering_history()
            
            return {
                'success': False,
                'message': f'çµ¦æ°´ã‚¨ãƒ©ãƒ¼: {str(e)}',
                'error': 'WATERING_ERROR'
            }
        
        finally:
            self.is_watering = False
    
    def stop_watering(self) -> Dict[str, Any]:
        """çµ¦æ°´å¼·åˆ¶åœæ­¢"""
        try:
            if self.is_watering:
                GPIO.output(self.relay_pin, GPIO.HIGH)
                self.is_watering = False
                self.logger.info("çµ¦æ°´å¼·åˆ¶åœæ­¢")
                return {'success': True, 'message': 'çµ¦æ°´åœæ­¢å®Œäº†'}
            else:
                return {'success': False, 'message': 'çµ¦æ°´ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“'}
        except Exception as e:
            self.logger.error(f"çµ¦æ°´åœæ­¢ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return {'success': False, 'message': f'åœæ­¢ã‚¨ãƒ©ãƒ¼: {str(e)}'}
    
    def reset_consecutive_count(self):
        """é€£ç¶šçµ¦æ°´ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ"""
        self.consecutive_watering_count = 0
        self.logger.info("é€£ç¶šçµ¦æ°´ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ")
    
    def get_status(self) -> Dict[str, Any]:
        """çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å–å¾—"""
        return {
            'is_watering': self.is_watering,
            'last_watering_time': self.last_watering_time.isoformat() if self.last_watering_time else None,
            'consecutive_watering_count': self.consecutive_watering_count,
            'max_consecutive_waterings': self.max_consecutive_waterings,
            'soil_moisture_threshold': self.soil_moisture_threshold,
            'watering_interval_hours': self.watering_interval_hours,
            'watering_duration_seconds': self.watering_duration_seconds,
            'water_amount_ml': self.water_amount_ml,
            'history_count': len(self.watering_history)
        }
    
    def get_recent_history(self, count: int = 10) -> List[Dict[str, Any]]:
        """æœ€è¿‘ã®çµ¦æ°´å±¥æ­´å–å¾—"""
        return self.watering_history[-count:] if self.watering_history else []
    
    def cleanup(self):
        """ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            GPIO.output(self.relay_pin, GPIO.HIGH)  # ãƒªãƒ¬ãƒ¼OFF
            GPIO.cleanup()
            self.logger.info("GPIOã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            self.logger.error(f"ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {str(e)}")
```

### Step 3: è‡ªå‹•çµ¦æ°´ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

#### 3.1 è‡ªå‹•çµ¦æ°´ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
```python
# src/watering/auto_watering_manager.py
import threading
import time
import logging
from datetime import datetime
from typing import Dict, Any
from .watering_controller import WateringController
from ..sensors.sensor_manager import SensorManager
from ..notifications.line_notify import LineNotify

class AutoWateringManager:
    """è‡ªå‹•çµ¦æ°´ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, sensor_manager: SensorManager, line_notify: LineNotify):
        self.sensor_manager = sensor_manager
        self.line_notify = line_notify
        self.watering_controller = WateringController()
        self.logger = logging.getLogger("auto_watering_manager")
        
        self.running = False
        self.monitor_thread = None
        self.check_interval = 60  # 1åˆ†é–“éš”ã§ãƒã‚§ãƒƒã‚¯
        
    def start_auto_watering(self):
        """è‡ªå‹•çµ¦æ°´é–‹å§‹"""
        if self.running:
            self.logger.warning("è‡ªå‹•çµ¦æ°´ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™")
            return
        
        self.running = True
        self.monitor_thread = threading.Thread(
            target=self._monitor_and_water,
            daemon=True
        )
        self.monitor_thread.start()
        self.logger.info("è‡ªå‹•çµ¦æ°´ç›£è¦–é–‹å§‹")
    
    def stop_auto_watering(self):
        """è‡ªå‹•çµ¦æ°´åœæ­¢"""
        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        self.logger.info("è‡ªå‹•çµ¦æ°´ç›£è¦–åœæ­¢")
    
    def _monitor_and_water(self):
        """çµ¦æ°´ç›£è¦–ã¨å®Ÿè¡Œ"""
        while self.running:
            try:
                # ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—
                sensor_data = self.sensor_manager.get_latest_data()
                
                # åœŸå£Œæ°´åˆ†ãƒ‡ãƒ¼ã‚¿ç¢ºèª
                soil_moisture_data = sensor_data.get('soil_moisture', {})
                if 'error' in soil_moisture_data:
                    self.logger.error(f"åœŸå£Œæ°´åˆ†ã‚»ãƒ³ã‚µãƒ¼ã‚¨ãƒ©ãƒ¼: {soil_moisture_data['error']}")
                    time.sleep(self.check_interval)
                    continue
                
                soil_moisture = soil_moisture_data.get('moisture_percentage', 0)
                
                # æ°´ä½ãƒ‡ãƒ¼ã‚¿ç¢ºèª
                water_level_data = sensor_data.get('water_level', {})
                if 'error' in water_level_data:
                    self.logger.error(f"ãƒ•ãƒ­ãƒ¼ãƒˆã‚¹ã‚¤ãƒƒãƒã‚¨ãƒ©ãƒ¼: {water_level_data['error']}")
                    time.sleep(self.check_interval)
                    continue
                
                water_available = water_level_data.get('is_water_available', False)
                
                # çµ¦æ°´åˆ¤å®š
                if soil_moisture <= self.watering_controller.soil_moisture_threshold:
                    self.logger.info(f"åœŸå£Œæ°´åˆ†ä½ä¸‹æ¤œçŸ¥: {soil_moisture}%")
                    
                    # çµ¦æ°´å®Ÿè¡Œ
                    result = self.watering_controller.start_watering(
                        soil_moisture, water_available
                    )
                    
                    if result['success']:
                        # çµ¦æ°´æˆåŠŸé€šçŸ¥
                        self.line_notify.send_watering_notification(
                            self.watering_controller.water_amount_ml
                        )
                        self.logger.info("çµ¦æ°´å®Œäº†é€šçŸ¥é€ä¿¡")
                    else:
                        # çµ¦æ°´å¤±æ•—é€šçŸ¥
                        error_msg = result.get('message', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')
                        self.line_notify.send_system_error(f"çµ¦æ°´å¤±æ•—: {error_msg}")
                        self.logger.error(f"çµ¦æ°´å¤±æ•—: {error_msg}")
                
                # æ°´ã‚¿ãƒ³ã‚¯ç©ºè­¦å‘Š
                if not water_available:
                    self.logger.warning("æ°´ã‚¿ãƒ³ã‚¯ç©ºè­¦å‘Š")
                    self.line_notify.send_water_tank_empty()
                
                time.sleep(self.check_interval)
                
            except Exception as e:
                self.logger.error(f"è‡ªå‹•çµ¦æ°´ç›£è¦–ã‚¨ãƒ©ãƒ¼: {str(e)}")
                time.sleep(30)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯30ç§’å¾…æ©Ÿ
    
    def manual_watering(self) -> Dict[str, Any]:
        """æ‰‹å‹•çµ¦æ°´å®Ÿè¡Œ"""
        try:
            # ç¾åœ¨ã®ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—
            sensor_data = self.sensor_manager.get_latest_data()
            soil_moisture = sensor_data.get('soil_moisture', {}).get('moisture_percentage', 0)
            water_available = sensor_data.get('water_level', {}).get('is_water_available', True)
            
            # æ‰‹å‹•çµ¦æ°´å®Ÿè¡Œ
            result = self.watering_controller.start_watering(soil_moisture, water_available)
            
            if result['success']:
                # æ‰‹å‹•çµ¦æ°´å®Œäº†é€šçŸ¥
                self.line_notify.send_message(
                    f"ğŸŒ± æ‰‹å‹•çµ¦æ°´å®Œäº†ï¼\n"
                    f"ğŸ’§ çµ¦æ°´é‡: {self.watering_controller.water_amount_ml}ml\n"
                    f"â° æ™‚åˆ»: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                )
            
            return result
            
        except Exception as e:
            self.logger.error(f"æ‰‹å‹•çµ¦æ°´ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return {
                'success': False,
                'message': f'æ‰‹å‹•çµ¦æ°´ã‚¨ãƒ©ãƒ¼: {str(e)}',
                'error': 'MANUAL_WATERING_ERROR'
            }
    
    def emergency_stop(self) -> Dict[str, Any]:
        """ç·Šæ€¥åœæ­¢"""
        try:
            result = self.watering_controller.stop_watering()
            
            # ç·Šæ€¥åœæ­¢é€šçŸ¥
            self.line_notify.send_message(
                f"ğŸš¨ ç·Šæ€¥åœæ­¢å®Ÿè¡Œï¼\n"
                f"â° æ™‚åˆ»: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"ã‚·ã‚¹ãƒ†ãƒ ã‚’ç¢ºèªã—ã¦ãã ã•ã„"
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"ç·Šæ€¥åœæ­¢ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return {
                'success': False,
                'message': f'ç·Šæ€¥åœæ­¢ã‚¨ãƒ©ãƒ¼: {str(e)}',
                'error': 'EMERGENCY_STOP_ERROR'
            }
    
    def get_watering_status(self) -> Dict[str, Any]:
        """çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å–å¾—"""
        return {
            'auto_watering_running': self.running,
            'watering_controller_status': self.watering_controller.get_status(),
            'recent_history': self.watering_controller.get_recent_history(5)
        }
    
    def update_settings(self, settings: Dict[str, Any]) -> Dict[str, Any]:
        """çµ¦æ°´è¨­å®šæ›´æ–°"""
        try:
            if 'soil_moisture_threshold' in settings:
                self.watering_controller.soil_moisture_threshold = settings['soil_moisture_threshold']
            
            if 'watering_interval_hours' in settings:
                self.watering_controller.watering_interval_hours = settings['watering_interval_hours']
            
            if 'watering_duration_seconds' in settings:
                self.watering_controller.watering_duration_seconds = settings['watering_duration_seconds']
            
            if 'water_amount_ml' in settings:
                self.watering_controller.water_amount_ml = settings['water_amount_ml']
            
            self.logger.info(f"çµ¦æ°´è¨­å®šæ›´æ–°: {settings}")
            return {'success': True, 'message': 'è¨­å®šæ›´æ–°å®Œäº†'}
            
        except Exception as e:
            self.logger.error(f"è¨­å®šæ›´æ–°ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return {'success': False, 'message': f'è¨­å®šæ›´æ–°ã‚¨ãƒ©ãƒ¼: {str(e)}'}
```

### Step 4: Flaskçµ±åˆ

#### 4.1 Web APIå®Ÿè£…
```python
# src/api/watering_api.py
from flask import Blueprint, request, jsonify
import logging
from ..watering.auto_watering_manager import AutoWateringManager

watering_bp = Blueprint('watering', __name__)
logger = logging.getLogger("watering_api")

# ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ã«ç®¡ç†ï¼‰
auto_watering_manager = None

def init_watering_api(sensor_manager, line_notify):
    """çµ¦æ°´APIåˆæœŸåŒ–"""
    global auto_watering_manager
    auto_watering_manager = AutoWateringManager(sensor_manager, line_notify)

@watering_bp.route('/watering/status', methods=['GET'])
def get_watering_status():
    """çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å–å¾—"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': 'çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'}), 500
        
        status = auto_watering_manager.get_watering_status()
        return jsonify(status)
    except Exception as e:
        logger.error(f"çµ¦æ°´çŠ¶æ…‹å–å¾—ã‚¨ãƒ©ãƒ¼: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/manual', methods=['POST'])
def manual_watering():
    """æ‰‹å‹•çµ¦æ°´å®Ÿè¡Œ"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': 'çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'}), 500
        
        result = auto_watering_manager.manual_watering()
        return jsonify(result)
    except Exception as e:
        logger.error(f"æ‰‹å‹•çµ¦æ°´ã‚¨ãƒ©ãƒ¼: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/emergency_stop', methods=['POST'])
def emergency_stop():
    """ç·Šæ€¥åœæ­¢"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': 'çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'}), 500
        
        result = auto_watering_manager.emergency_stop()
        return jsonify(result)
    except Exception as e:
        logger.error(f"ç·Šæ€¥åœæ­¢ã‚¨ãƒ©ãƒ¼: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/settings', methods=['GET', 'POST'])
def watering_settings():
    """çµ¦æ°´è¨­å®šå–å¾—ãƒ»æ›´æ–°"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': 'çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'}), 500
        
        if request.method == 'GET':
            # è¨­å®šå–å¾—
            status = auto_watering_manager.get_watering_status()
            settings = {
                'soil_moisture_threshold': status['watering_controller_status']['soil_moisture_threshold'],
                'watering_interval_hours': status['watering_controller_status']['watering_interval_hours'],
                'watering_duration_seconds': status['watering_controller_status']['watering_duration_seconds'],
                'water_amount_ml': status['watering_controller_status']['water_amount_ml']
            }
            return jsonify(settings)
        
        elif request.method == 'POST':
            # è¨­å®šæ›´æ–°
            settings = request.get_json()
            result = auto_watering_manager.update_settings(settings)
            return jsonify(result)
    
    except Exception as e:
        logger.error(f"çµ¦æ°´è¨­å®šã‚¨ãƒ©ãƒ¼: {str(e)}")
        return jsonify({'error': str(e)}), 500

@watering_bp.route('/watering/history', methods=['GET'])
def get_watering_history():
    """çµ¦æ°´å±¥æ­´å–å¾—"""
    try:
        if not auto_watering_manager:
            return jsonify({'error': 'çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'}), 500
        
        count = request.args.get('count', 10, type=int)
        history = auto_watering_manager.watering_controller.get_recent_history(count)
        return jsonify({'history': history})
    except Exception as e:
        logger.error(f"çµ¦æ°´å±¥æ­´å–å¾—ã‚¨ãƒ©ãƒ¼: {str(e)}")
        return jsonify({'error': str(e)}), 500
```

### Step 5: ãƒ†ã‚¹ãƒˆå®Ÿè£…

#### 5.1 çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
```python
# test_watering.py
import time
import logging
from src.sensors.sensor_manager import SensorManager
from src.notifications.line_notify import LineNotify
from src.watering.auto_watering_manager import AutoWateringManager

# ãƒ­ã‚°è¨­å®š
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

def test_watering_system():
    """çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ"""
    print("ğŸ’§ çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹")
    
    # ã‚»ãƒ³ã‚µãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
    sensor_manager = SensorManager()
    
    # LINEé€šçŸ¥åˆæœŸåŒ–ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    line_notify = LineNotify()
    
    # è‡ªå‹•çµ¦æ°´ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
    auto_watering_manager = AutoWateringManager(sensor_manager, line_notify)
    
    # çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª
    print("\nğŸ“Š çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹")
    status = auto_watering_manager.get_watering_status()
    print(f"çŠ¶æ…‹: {status}")
    
    # æ‰‹å‹•çµ¦æ°´ãƒ†ã‚¹ãƒˆ
    print("\nğŸŒ± æ‰‹å‹•çµ¦æ°´ãƒ†ã‚¹ãƒˆ")
    result = auto_watering_manager.manual_watering()
    print(f"çµæœ: {result}")
    
    # è¨­å®šæ›´æ–°ãƒ†ã‚¹ãƒˆ
    print("\nâš™ï¸ è¨­å®šæ›´æ–°ãƒ†ã‚¹ãƒˆ")
    new_settings = {
        'soil_moisture_threshold': 150,
        'watering_duration_seconds': 3
    }
    update_result = auto_watering_manager.update_settings(new_settings)
    print(f"æ›´æ–°çµæœ: {update_result}")
    
    # è‡ªå‹•çµ¦æ°´ãƒ†ã‚¹ãƒˆï¼ˆ30ç§’é–“ï¼‰
    print("\nğŸ”„ è‡ªå‹•çµ¦æ°´ãƒ†ã‚¹ãƒˆ (30ç§’é–“)")
    auto_watering_manager.start_auto_watering()
    
    for i in range(6):
        time.sleep(5)
        current_status = auto_watering_manager.get_watering_status()
        print(f"5ç§’å¾Œ: è‡ªå‹•çµ¦æ°´å®Ÿè¡Œä¸­={current_status['auto_watering_running']}")
    
    auto_watering_manager.stop_auto_watering()
    
    # çµ¦æ°´å±¥æ­´ç¢ºèª
    print("\nğŸ“‹ çµ¦æ°´å±¥æ­´")
    history = auto_watering_manager.watering_controller.get_recent_history(5)
    for record in history:
        print(f"å±¥æ­´: {record}")
    
    print("âœ… çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº†")

if __name__ == "__main__":
    test_watering_system()
```

### Step 6: ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

#### 6.1 ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•

**ãƒªãƒ¬ãƒ¼ãŒå‹•ä½œã—ãªã„:**
```bash
# GPIOçŠ¶æ…‹ç¢ºèª
gpio read 16

# æœŸå¾…ã•ã‚Œã‚‹å€¤: 1 (OFFçŠ¶æ…‹)
```

**ãƒãƒ³ãƒ—ãŒå‹•ä½œã—ãªã„:**
```bash
# é›»æºç¢ºèª
# 12Vé›»æºã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®å‹•ä½œç¢ºèª
# ãƒãƒ³ãƒ—ã®æ¥ç¶šç¢ºèª
```

**çµ¦æ°´ãŒå®Ÿè¡Œã•ã‚Œãªã„:**
```bash
# ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ç¢ºèª
python test_sensors.py

# çµ¦æ°´æ¡ä»¶ç¢ºèª
# - åœŸå£Œæ°´åˆ†å€¤ <= 159
# - å‰å›çµ¦æ°´ã‹ã‚‰12æ™‚é–“çµŒé
# - æ°´ã‚¿ãƒ³ã‚¯ã«æ°´ãŒã‚ã‚‹
```

#### 6.2 ãƒ‡ãƒãƒƒã‚°ç”¨ã‚³ãƒãƒ³ãƒ‰
```bash
# çµ¦æ°´ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
cd /home/pi/smart-planter
python test_watering.py

# çµ¦æ°´å±¥æ­´ç¢ºèª
cat /mnt/usb-storage/watering_data/watering_history.json

# GPIOçŠ¶æ…‹ç¢ºèª
gpio readall
```

---

## ğŸ“Š å®Ÿè£…å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢æ¥ç¶šå®Œäº†
- [ ] ãƒªãƒ¬ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¥ç¶šå®Œäº†
- [ ] çµ¦æ°´åˆ¶å¾¡ã‚¯ãƒ©ã‚¹å®Ÿè£…å®Œäº†
- [ ] è‡ªå‹•çµ¦æ°´ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼å®Ÿè£…å®Œäº†
- [ ] Web APIå®Ÿè£…å®Œäº†
- [ ] ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œå®Œäº†
- [ ] å®‰å…¨æ©Ÿèƒ½ç¢ºèªå®Œäº†
- [ ] çµ¦æ°´å±¥æ­´æ©Ÿèƒ½ç¢ºèªå®Œäº†
- [ ] LINEé€šçŸ¥çµ±åˆå®Œäº†
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç¢ºèªå®Œäº†

---

## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. **Web UIå®Ÿè£…**: çµ¦æ°´åˆ¶å¾¡ã®Webã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
2. **ãƒ‡ãƒ¼ã‚¿å¯è¦–åŒ–**: çµ¦æ°´å±¥æ­´ã®ã‚°ãƒ©ãƒ•è¡¨ç¤º
3. **è¨­å®šç”»é¢**: çµ¦æ°´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹•çš„å¤‰æ›´
4. **çµ±åˆãƒ†ã‚¹ãƒˆ**: å…¨ã‚·ã‚¹ãƒ†ãƒ ã®å‹•ä½œç¢ºèª

---

**ä½œæˆæ—¥**: 2025å¹´1æœˆ
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0
**ãƒãƒ¼ãƒ **: KEBABS

