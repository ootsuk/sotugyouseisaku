# データ管理機能 詳細実装手順書
## すくすくミントちゃん - データ保存・管理システム

---

## 📋 概要
センサーデータ、給水履歴、画像データの保存・管理・削除機能の詳細実装手順書

## 🎯 実装目標
- CSV形式でのセンサーデータ保存
- JSON形式での給水履歴保存
- JPEG形式での画像保存
- 90日間の自動削除機能
- USBストレージへの安全な保存
- データの整合性チェック

---

## 🛠️ 必要な環境

### ハードウェア
- USBストレージ (16GB以上)
- Raspberry Pi 5

### ソフトウェア
- Python 3.11.x
- pandas (データ処理)
- Pillow (画像処理)
- pathlib (ファイル管理)

---

## 🔧 実装手順

### Step 1: データ管理クラス実装

#### 1.1 基本データ管理クラス
```python
# src/data/data_manager.py
import os
import json
import csv
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Any, List, Optional
import pandas as pd
from PIL import Image
import shutil

class DataManager:
    """データ管理クラス"""
    
    def __init__(self, base_path: str = "/mnt/usb-storage"):
        self.base_path = Path(base_path)
        self.logger = logging.getLogger("data_manager")
        
        # データ保存期間（日）
        self.retention_days = 90
        
        # ディレクトリ構造
        self.directories = {
            'sensor_data': self.base_path / 'sensor_data',
            'watering_history': self.base_path / 'watering_history',
            'images': self.base_path / 'images',
            'logs': self.base_path / 'logs',
            'backup': self.base_path / 'backup'
        }
        
        # ディレクトリ作成
        self._create_directories()
        
        # データベースファイル
        self.metadata_file = self.base_path / 'metadata.json'
        self._load_metadata()
    
    def _create_directories(self):
        """必要なディレクトリを作成"""
        for dir_name, dir_path in self.directories.items():
            dir_path.mkdir(parents=True, exist_ok=True)
            self.logger.info(f"ディレクトリ作成: {dir_path}")
    
    def _load_metadata(self):
        """メタデータを読み込み"""
        try:
            if self.metadata_file.exists():
                with open(self.metadata_file, 'r', encoding='utf-8') as f:
                    self.metadata = json.load(f)
            else:
                self.metadata = {
                    'created_at': datetime.now().isoformat(),
                    'last_cleanup': None,
                    'file_counts': {},
                    'total_size_bytes': 0
                }
                self._save_metadata()
        except Exception as e:
            self.logger.error(f"メタデータ読み込みエラー: {str(e)}")
            self.metadata = {}
    
    def _save_metadata(self):
        """メタデータを保存"""
        try:
            with open(self.metadata_file, 'w', encoding='utf-8') as f:
                json.dump(self.metadata, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"メタデータ保存エラー: {str(e)}")
    
    def save_sensor_data(self, data: Dict[str, Any]) -> bool:
        """センサーデータをCSV形式で保存"""
        try:
            timestamp = datetime.now()
            filename = f"sensor_data_{timestamp.strftime('%Y%m%d')}.csv"
            filepath = self.directories['sensor_data'] / filename
            
            # CSVファイルの存在確認
            file_exists = filepath.exists()
            
            # データ準備
            csv_data = {
                'timestamp': timestamp.isoformat(),
                'temperature': data.get('temperature_humidity', {}).get('temperature', ''),
                'humidity': data.get('temperature_humidity', {}).get('humidity', ''),
                'soil_moisture_raw': data.get('soil_moisture', {}).get('raw_value', ''),
                'soil_moisture_filtered': data.get('soil_moisture', {}).get('filtered_value', ''),
                'soil_moisture_percentage': data.get('soil_moisture', {}).get('moisture_percentage', ''),
                'water_level': data.get('water_level', {}).get('is_water_available', ''),
                'water_level_raw': data.get('water_level', {}).get('raw_state', '')
            }
            
            # CSV書き込み
            with open(filepath, 'a', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=csv_data.keys())
                if not file_exists:
                    writer.writeheader()
                writer.writerow(csv_data)
            
            self._update_file_count('sensor_data')
            self.logger.debug(f"センサーデータ保存: {filepath}")
            return True
            
        except Exception as e:
            self.logger.error(f"センサーデータ保存エラー: {str(e)}")
            return False
    
    def save_watering_record(self, record: Dict[str, Any]) -> bool:
        """給水記録をJSON形式で保存"""
        try:
            timestamp = datetime.now()
            filename = f"watering_{timestamp.strftime('%Y%m%d')}.json"
            filepath = self.directories['watering_history'] / filename
            
            # 既存データ読み込み
            existing_data = []
            if filepath.exists():
                with open(filepath, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
            
            # 新しい記録追加
            record['saved_at'] = timestamp.isoformat()
            existing_data.append(record)
            
            # ファイル保存
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(existing_data, f, ensure_ascii=False, indent=2)
            
            self._update_file_count('watering_history')
            self.logger.debug(f"給水記録保存: {filepath}")
            return True
            
        except Exception as e:
            self.logger.error(f"給水記録保存エラー: {str(e)}")
            return False
    
    def save_image(self, image_data: bytes, metadata: Dict[str, Any] = None) -> Optional[str]:
        """画像をJPEG形式で保存"""
        try:
            timestamp = datetime.now()
            filename = f"{timestamp.strftime('%Y%m%d_%H%M%S')}.jpg"
            filepath = self.directories['images'] / filename
            
            # 画像保存
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            # メタデータ保存
            if metadata:
                metadata_file = filepath.with_suffix('.json')
                metadata['filename'] = filename
                metadata['saved_at'] = timestamp.isoformat()
                metadata['file_size'] = len(image_data)
                
                with open(metadata_file, 'w', encoding='utf-8') as f:
                    json.dump(metadata, f, ensure_ascii=False, indent=2)
            
            self._update_file_count('images')
            self.logger.debug(f"画像保存: {filepath}")
            return str(filepath)
            
        except Exception as e:
            self.logger.error(f"画像保存エラー: {str(e)}")
            return None
    
    def get_sensor_data(self, start_date: datetime = None, end_date: datetime = None) -> List[Dict[str, Any]]:
        """センサーデータを取得"""
        try:
            data = []
            
            # 日付範囲の設定
            if not start_date:
                start_date = datetime.now() - timedelta(days=7)  # デフォルト7日間
            if not end_date:
                end_date = datetime.now()
            
            # CSVファイルを読み込み
            for file_path in self.directories['sensor_data'].glob('sensor_data_*.csv'):
                try:
                    df = pd.read_csv(file_path)
                    df['timestamp'] = pd.to_datetime(df['timestamp'])
                    
                    # 日付範囲でフィルタリング
                    filtered_df = df[(df['timestamp'] >= start_date) & (df['timestamp'] <= end_date)]
                    
                    for _, row in filtered_df.iterrows():
                        data.append(row.to_dict())
                        
                except Exception as e:
                    self.logger.error(f"CSVファイル読み込みエラー {file_path}: {str(e)}")
            
            return sorted(data, key=lambda x: x['timestamp'])
            
        except Exception as e:
            self.logger.error(f"センサーデータ取得エラー: {str(e)}")
            return []
    
    def get_watering_history(self, days: int = 30) -> List[Dict[str, Any]]:
        """給水履歴を取得"""
        try:
            history = []
            start_date = datetime.now() - timedelta(days=days)
            
            # JSONファイルを読み込み
            for file_path in self.directories['watering_history'].glob('watering_*.json'):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        file_data = json.load(f)
                    
                    for record in file_data:
                        record_date = datetime.fromisoformat(record['timestamp'])
                        if record_date >= start_date:
                            history.append(record)
                            
                except Exception as e:
                    self.logger.error(f"JSONファイル読み込みエラー {file_path}: {str(e)}")
            
            return sorted(history, key=lambda x: x['timestamp'])
            
        except Exception as e:
            self.logger.error(f"給水履歴取得エラー: {str(e)}")
            return []
    
    def get_images(self, days: int = 30) -> List[Dict[str, Any]]:
        """画像一覧を取得"""
        try:
            images = []
            start_date = datetime.now() - timedelta(days=days)
            
            for file_path in self.directories['images'].glob('*.jpg'):
                try:
                    # ファイルの作成日時を取得
                    file_time = datetime.fromtimestamp(file_path.stat().st_mtime)
                    
                    if file_time >= start_date:
                        # メタデータファイルの確認
                        metadata_file = file_path.with_suffix('.json')
                        metadata = {}
                        if metadata_file.exists():
                            with open(metadata_file, 'r', encoding='utf-8') as f:
                                metadata = json.load(f)
                        
                        images.append({
                            'filename': file_path.name,
                            'filepath': str(file_path),
                            'timestamp': file_time.isoformat(),
                            'file_size': file_path.stat().st_size,
                            'metadata': metadata
                        })
                        
                except Exception as e:
                    self.logger.error(f"画像ファイル処理エラー {file_path}: {str(e)}")
            
            return sorted(images, key=lambda x: x['timestamp'])
            
        except Exception as e:
            self.logger.error(f"画像一覧取得エラー: {str(e)}")
            return []
    
    def cleanup_old_data(self) -> Dict[str, int]:
        """古いデータを削除"""
        try:
            cutoff_date = datetime.now() - timedelta(days=self.retention_days)
            deleted_counts = {
                'sensor_data': 0,
                'watering_history': 0,
                'images': 0
            }
            
            # センサーデータ削除
            for file_path in self.directories['sensor_data'].glob('sensor_data_*.csv'):
                if datetime.fromtimestamp(file_path.stat().st_mtime) < cutoff_date:
                    file_path.unlink()
                    deleted_counts['sensor_data'] += 1
            
            # 給水履歴削除
            for file_path in self.directories['watering_history'].glob('watering_*.json'):
                if datetime.fromtimestamp(file_path.stat().st_mtime) < cutoff_date:
                    file_path.unlink()
                    deleted_counts['watering_history'] += 1
            
            # 画像削除
            for file_path in self.directories['images'].glob('*.jpg'):
                if datetime.fromtimestamp(file_path.stat().st_mtime) < cutoff_date:
                    file_path.unlink()
                    # 対応するメタデータファイルも削除
                    metadata_file = file_path.with_suffix('.json')
                    if metadata_file.exists():
                        metadata_file.unlink()
                    deleted_counts['images'] += 1
            
            # メタデータ更新
            self.metadata['last_cleanup'] = datetime.now().isoformat()
            self._save_metadata()
            
            self.logger.info(f"データクリーンアップ完了: {deleted_counts}")
            return deleted_counts
            
        except Exception as e:
            self.logger.error(f"データクリーンアップエラー: {str(e)}")
            return {}
    
    def get_storage_info(self) -> Dict[str, Any]:
        """ストレージ情報を取得"""
        try:
            total_size = 0
            file_counts = {}
            
            for dir_name, dir_path in self.directories.items():
                if dir_path.exists():
                    dir_size = sum(f.stat().st_size for f in dir_path.rglob('*') if f.is_file())
                    dir_count = len(list(dir_path.rglob('*')))
                    
                    total_size += dir_size
                    file_counts[dir_name] = {
                        'count': dir_count,
                        'size_bytes': dir_size,
                        'size_mb': round(dir_size / (1024 * 1024), 2)
                    }
            
            return {
                'total_size_bytes': total_size,
                'total_size_mb': round(total_size / (1024 * 1024), 2),
                'total_size_gb': round(total_size / (1024 * 1024 * 1024), 2),
                'file_counts': file_counts,
                'retention_days': self.retention_days,
                'last_cleanup': self.metadata.get('last_cleanup'),
                'base_path': str(self.base_path)
            }
            
        except Exception as e:
            self.logger.error(f"ストレージ情報取得エラー: {str(e)}")
            return {}
    
    def backup_data(self, backup_name: str = None) -> Optional[str]:
        """データのバックアップを作成"""
        try:
            if not backup_name:
                backup_name = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            backup_path = self.directories['backup'] / backup_name
            backup_path.mkdir(exist_ok=True)
            
            # 各ディレクトリをコピー
            for dir_name, dir_path in self.directories.items():
                if dir_name != 'backup' and dir_path.exists():
                    dest_path = backup_path / dir_name
                    shutil.copytree(dir_path, dest_path)
            
            # メタデータもコピー
            if self.metadata_file.exists():
                shutil.copy2(self.metadata_file, backup_path / 'metadata.json')
            
            self.logger.info(f"バックアップ作成完了: {backup_path}")
            return str(backup_path)
            
        except Exception as e:
            self.logger.error(f"バックアップ作成エラー: {str(e)}")
            return None
    
    def _update_file_count(self, data_type: str):
        """ファイルカウントを更新"""
        try:
            if 'file_counts' not in self.metadata:
                self.metadata['file_counts'] = {}
            
            if data_type not in self.metadata['file_counts']:
                self.metadata['file_counts'][data_type] = 0
            
            self.metadata['file_counts'][data_type] += 1
            self._save_metadata()
        except Exception as e:
            self.logger.error(f"ファイルカウント更新エラー: {str(e)}")
```

### Step 2: データ管理マネージャー

#### 2.1 統合データ管理システム
```python
# src/data/data_manager_service.py
import threading
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, Any
from .data_manager import DataManager

class DataManagerService:
    """データ管理サービス"""
    
    def __init__(self):
        self.data_manager = DataManager()
        self.logger = logging.getLogger("data_manager_service")
        
        self.running = False
        self.save_thread = None
        self.cleanup_thread = None
        
        # 保存間隔（秒）
        self.save_interval = 300  # 5分間隔
        self.cleanup_interval = 86400  # 24時間間隔
        
    def start_service(self):
        """データ管理サービス開始"""
        if self.running:
            self.logger.warning("データ管理サービスは既に実行中です")
            return
        
        self.running = True
        
        # データ保存スレッド
        self.save_thread = threading.Thread(
            target=self._periodic_save,
            daemon=True
        )
        self.save_thread.start()
        
        # クリーンアップスレッド
        self.cleanup_thread = threading.Thread(
            target=self._periodic_cleanup,
            daemon=True
        )
        self.cleanup_thread.start()
        
        self.logger.info("データ管理サービス開始")
    
    def stop_service(self):
        """データ管理サービス停止"""
        self.running = False
        if self.save_thread:
            self.save_thread.join(timeout=5)
        if self.cleanup_thread:
            self.cleanup_thread.join(timeout=5)
        self.logger.info("データ管理サービス停止")
    
    def _periodic_save(self):
        """定期的なデータ保存"""
        while self.running:
            try:
                # センサーデータの保存は各センサーシステムで実行
                # ここではメタデータの更新のみ
                time.sleep(self.save_interval)
            except Exception as e:
                self.logger.error(f"定期保存エラー: {str(e)}")
                time.sleep(60)
    
    def _periodic_cleanup(self):
        """定期的なデータクリーンアップ"""
        while self.running:
            try:
                time.sleep(self.cleanup_interval)
                
                if self.running:
                    deleted_counts = self.data_manager.cleanup_old_data()
                    self.logger.info(f"定期クリーンアップ完了: {deleted_counts}")
                    
            except Exception as e:
                self.logger.error(f"定期クリーンアップエラー: {str(e)}")
                time.sleep(3600)  # エラー時は1時間待機
    
    def save_sensor_data(self, data: Dict[str, Any]) -> bool:
        """センサーデータ保存"""
        return self.data_manager.save_sensor_data(data)
    
    def save_watering_record(self, record: Dict[str, Any]) -> bool:
        """給水記録保存"""
        return self.data_manager.save_watering_record(record)
    
    def save_image(self, image_data: bytes, metadata: Dict[str, Any] = None) -> Optional[str]:
        """画像保存"""
        return self.data_manager.save_image(image_data, metadata)
    
    def get_sensor_data(self, days: int = 7) -> List[Dict[str, Any]]:
        """センサーデータ取得"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        return self.data_manager.get_sensor_data(start_date, end_date)
    
    def get_watering_history(self, days: int = 30) -> List[Dict[str, Any]]:
        """給水履歴取得"""
        return self.data_manager.get_watering_history(days)
    
    def get_images(self, days: int = 30) -> List[Dict[str, Any]]:
        """画像一覧取得"""
        return self.data_manager.get_images(days)
    
    def get_storage_info(self) -> Dict[str, Any]:
        """ストレージ情報取得"""
        return self.data_manager.get_storage_info()
    
    def create_backup(self, backup_name: str = None) -> Optional[str]:
        """バックアップ作成"""
        return self.data_manager.backup_data(backup_name)
    
    def manual_cleanup(self) -> Dict[str, int]:
        """手動クリーンアップ"""
        return self.data_manager.cleanup_old_data()
```

### Step 3: システム統合

#### 3.1 既存システムとの統合
```python
# src/sensors/sensor_manager.py に追加
class SensorManager:
    def __init__(self, data_manager_service=None):
        # 既存の初期化コード...
        self.data_manager_service = data_manager_service
    
    def _monitor_temperature_humidity(self):
        """温湿度センサー監視（データ保存追加）"""
        while self.running:
            try:
                data = self.sensors['temperature_humidity'].read_data()
                if 'error' not in data:
                    self.data_cache['temperature_humidity'] = data
                    
                    # データ保存
                    if self.data_manager_service:
                        self.data_manager_service.save_sensor_data(self.data_cache)
                    
                    self.logger.debug(f"温湿度データ更新: {data}")
                else:
                    self.logger.error(f"温湿度センサーエラー: {data['error']}")
                
                time.sleep(1800)  # 30分待機
                
            except Exception as e:
                self.logger.error(f"温湿度監視エラー: {str(e)}")
                time.sleep(60)

# src/watering/watering_controller.py に追加
class WateringController:
    def __init__(self, data_manager_service=None):
        # 既存の初期化コード...
        self.data_manager_service = data_manager_service
    
    def start_watering(self, soil_moisture: float, water_available: bool) -> Dict[str, Any]:
        # 既存の給水処理...
        
        # 履歴記録
        watering_record = {
            'timestamp': self.last_watering_time.isoformat(),
            'soil_moisture': soil_moisture,
            'duration_seconds': self.watering_duration_seconds,
            'water_amount_ml': self.water_amount_ml,
            'consecutive_count': self.consecutive_watering_count,
            'success': True
        }
        
        # データ保存
        if self.data_manager_service:
            self.data_manager_service.save_watering_record(watering_record)
        
        # 既存の処理続行...
```

### Step 4: API実装

#### 4.1 データ管理API
```python
# src/api/data_api.py
from flask import Blueprint, jsonify, request
import logging

data_bp = Blueprint('data', __name__)
logger = logging.getLogger("data_api")

@sensor_bp.route('/data/sensor', methods=['GET'])
def get_sensor_data():
    """センサーデータ取得"""
    try:
        from ..app import data_manager_service
        if not data_manager_service:
            return jsonify({'error': 'データ管理サービスが初期化されていません'}), 500
        
        days = request.args.get('days', 7, type=int)
        data = data_manager_service.get_sensor_data(days)
        return jsonify({'data': data})
    except Exception as e:
        logger.error(f"センサーデータ取得エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@sensor_bp.route('/data/watering', methods=['GET'])
def get_watering_history():
    """給水履歴取得"""
    try:
        from ..app import data_manager_service
        if not data_manager_service:
            return jsonify({'error': 'データ管理サービスが初期化されていません'}), 500
        
        days = request.args.get('days', 30, type=int)
        history = data_manager_service.get_watering_history(days)
        return jsonify({'history': history})
    except Exception as e:
        logger.error(f"給水履歴取得エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@sensor_bp.route('/data/images', methods=['GET'])
def get_images():
    """画像一覧取得"""
    try:
        from ..app import data_manager_service
        if not data_manager_service:
            return jsonify({'error': 'データ管理サービスが初期化されていません'}), 500
        
        days = request.args.get('days', 30, type=int)
        images = data_manager_service.get_images(days)
        return jsonify({'images': images})
    except Exception as e:
        logger.error(f"画像一覧取得エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@sensor_bp.route('/data/storage', methods=['GET'])
def get_storage_info():
    """ストレージ情報取得"""
    try:
        from ..app import data_manager_service
        if not data_manager_service:
            return jsonify({'error': 'データ管理サービスが初期化されていません'}), 500
        
        info = data_manager_service.get_storage_info()
        return jsonify(info)
    except Exception as e:
        logger.error(f"ストレージ情報取得エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@sensor_bp.route('/data/cleanup', methods=['POST'])
def manual_cleanup():
    """手動クリーンアップ"""
    try:
        from ..app import data_manager_service
        if not data_manager_service:
            return jsonify({'error': 'データ管理サービスが初期化されていません'}), 500
        
        deleted_counts = data_manager_service.manual_cleanup()
        return jsonify({'success': True, 'deleted_counts': deleted_counts})
    except Exception as e:
        logger.error(f"手動クリーンアップエラー: {str(e)}")
        return jsonify({'error': str(e)}), 500

@sensor_bp.route('/data/backup', methods=['POST'])
def create_backup():
    """バックアップ作成"""
    try:
        from ..app import data_manager_service
        if not data_manager_service:
            return jsonify({'error': 'データ管理サービスが初期化されていません'}), 500
        
        backup_name = request.json.get('backup_name') if request.json else None
        backup_path = data_manager_service.create_backup(backup_name)
        
        if backup_path:
            return jsonify({'success': True, 'backup_path': backup_path})
        else:
            return jsonify({'success': False, 'error': 'バックアップ作成失敗'})
    except Exception as e:
        logger.error(f"バックアップ作成エラー: {str(e)}")
        return jsonify({'error': str(e)}), 500
```

### Step 5: テスト実装

#### 5.1 データ管理テスト
```python
# test_data_management.py
import time
import logging
from src.data.data_manager_service import DataManagerService

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

def test_data_management():
    """データ管理テスト"""
    print("💾 データ管理テスト開始")
    
    # データ管理サービス初期化
    data_service = DataManagerService()
    
    # テストデータ作成
    test_sensor_data = {
        'temperature_humidity': {'temperature': 25.5, 'humidity': 60.0},
        'soil_moisture': {'moisture_percentage': 45.2, 'raw_value': 462},
        'water_level': {'is_water_available': True}
    }
    
    test_watering_record = {
        'timestamp': '2025-01-15T10:30:00',
        'soil_moisture': 45.2,
        'duration_seconds': 5,
        'water_amount_ml': 100,
        'success': True
    }
    
    # センサーデータ保存テスト
    print("\n📊 センサーデータ保存テスト")
    result = data_service.save_sensor_data(test_sensor_data)
    print(f"保存結果: {result}")
    
    # 給水記録保存テスト
    print("\n💧 給水記録保存テスト")
    result = data_service.save_watering_record(test_watering_record)
    print(f"保存結果: {result}")
    
    # データ取得テスト
    print("\n📋 データ取得テスト")
    sensor_data = data_service.get_sensor_data(7)
    print(f"センサーデータ件数: {len(sensor_data)}")
    
    watering_history = data_service.get_watering_history(30)
    print(f"給水履歴件数: {len(watering_history)}")
    
    images = data_service.get_images(30)
    print(f"画像件数: {len(images)}")
    
    # ストレージ情報取得テスト
    print("\n💾 ストレージ情報")
    storage_info = data_service.get_storage_info()
    print(f"ストレージ情報: {storage_info}")
    
    # バックアップ作成テスト
    print("\n🔄 バックアップ作成テスト")
    backup_path = data_service.create_backup("test_backup")
    print(f"バックアップパス: {backup_path}")
    
    # 手動クリーンアップテスト
    print("\n🧹 手動クリーンアップテスト")
    deleted_counts = data_service.manual_cleanup()
    print(f"削除件数: {deleted_counts}")
    
    print("✅ データ管理テスト完了")

if __name__ == "__main__":
    test_data_management()
```

---

## 📊 実装完了チェックリスト

- [ ] データ管理クラス実装完了
- [ ] センサーデータ保存機能完了
- [ ] 給水履歴保存機能完了
- [ ] 画像保存機能完了
- [ ] データ取得機能完了
- [ ] 自動削除機能完了
- [ ] バックアップ機能完了
- [ ] API実装完了
- [ ] テストスクリプト実行完了
- [ ] 既存システム統合完了
- [ ] エラーハンドリング確認完了

---

## 🎯 次のステップ

1. **統合テスト**: 全システムの動作確認
2. **パフォーマンス最適化**: 大量データ処理の最適化
3. **データ可視化**: グラフ表示機能の実装
4. **監視機能**: ストレージ使用量の監視

---

**作成日**: 2025年1月
**バージョン**: 1.0
**チーム**: KEBABS

