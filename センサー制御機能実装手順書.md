# センサー制御機能 詳細実装手順書
## すくすくミントちゃん - センサー制御システム

---

## 📋 概要
温湿度センサー(AHT25)と土壌水分センサー(SEN0193)の制御機能を実装するための詳細手順書

## 🎯 実装目標
- AHT25温湿度センサーのI2C通信制御
- SEN0193土壌水分センサーのADC制御
- センサー値のフィルタリング処理
- エラーハンドリングと故障時対応
- データ取得の定期実行

---

## 🛠️ 必要な環境

### ハードウェア
- Raspberry Pi 5
- 温湿度センサー AHT25
- 土壌水分センサー SEN0193
- ADC MCP3002
- ジャンパーワイヤー
- ブレッドボード

### ソフトウェア
- Python 3.11.x
- RPi.GPIO
- smbus2 (I2C通信用)
- spidev (SPI通信用)
- numpy (データ処理用)

---

## 🔧 実装手順

### Step 1: ハードウェア接続

#### 1.1 GPIOピン配置
```python
# GPIOピン定義
GPIO_PINS = {
    # I2C通信 (AHT25温湿度センサー)
    'I2C_SDA': 2,  # GPIO 2 (Pin 3)
    'I2C_SCL': 3,  # GPIO 3 (Pin 5)
    
    # SPI通信 (MCP3002 ADC)
    'SPI_MOSI': 10,  # GPIO 10 (Pin 19)
    'SPI_MISO': 9,   # GPIO 9 (Pin 21)
    'SPI_SCLK': 11,  # GPIO 11 (Pin 23)
    'SPI_CE0': 8,    # GPIO 8 (Pin 24)
    
    # フロートスイッチ
    'FLOAT_SWITCH': 18,  # GPIO 18 (Pin 12)
    
    # リレーモジュール (水ポンプ制御)
    'RELAY_PUMP': 16,    # GPIO 16 (Pin 36)
}
```

#### 1.2 配線図
```
AHT25温湿度センサー:
- VCC → 3.3V (Pin 1)
- GND → GND (Pin 6)
- SDA → GPIO 2 (Pin 3)
- SCL → GPIO 3 (Pin 5)

SEN0193土壌水分センサー:
- VCC → 5V (Pin 2)
- GND → GND (Pin 6)
- SIG → MCP3002 CH0

MCP3002 ADC:
- VDD → 3.3V (Pin 1)
- VREF → 3.3V (Pin 1)
- AGND → GND (Pin 6)
- DGND → GND (Pin 6)
- CLK → GPIO 11 (Pin 23)
- DOUT → GPIO 9 (Pin 21)
- DIN → GPIO 10 (Pin 19)
- CS/SHDN → GPIO 8 (Pin 24)
```

### Step 2: システム設定

#### 2.1 I2C・SPI有効化
```bash
# Raspberry Pi設定
sudo raspi-config

# 選択項目:
# 3 Interface Options
#   P4 I2C → Enable
#   P5 SPI → Enable

# 再起動
sudo reboot
```

#### 2.2 必要なライブラリインストール
```bash
# Pythonライブラリインストール
pip install RPi.GPIO
pip install smbus2
pip install spidev
pip install numpy
```

### Step 3: センサー制御クラス実装

#### 3.1 基本センサークラス
```python
# src/sensors/base_sensor.py
import time
import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class BaseSensor(ABC):
    """センサーの基底クラス"""
    
    def __init__(self, name: str, pin: int):
        self.name = name
        self.pin = pin
        self.error_count = 0
        self.max_errors = 3
        self.is_enabled = True
        self.logger = logging.getLogger(f"sensor.{name}")
        
    @abstractmethod
    def read_data(self) -> Dict[str, Any]:
        """センサーデータを読み取る"""
        pass
    
    @abstractmethod
    def initialize(self) -> bool:
        """センサーを初期化する"""
        pass
    
    def is_healthy(self) -> bool:
        """センサーの健全性をチェック"""
        return self.error_count < self.max_errors and self.is_enabled
    
    def reset_error_count(self):
        """エラーカウントをリセット"""
        self.error_count = 0
    
    def increment_error_count(self):
        """エラーカウントを増加"""
        self.error_count += 1
        if self.error_count >= self.max_errors:
            self.logger.error(f"{self.name} センサーが故障状態になりました")
            self.is_enabled = False
```

#### 3.2 AHT25温湿度センサークラス
```python
# src/sensors/aht25_sensor.py
import smbus2
import time
from typing import Dict, Any
from .base_sensor import BaseSensor

class AHT25Sensor(BaseSensor):
    """AHT25温湿度センサー制御クラス"""
    
    def __init__(self):
        super().__init__("AHT25", 0)
        self.bus = smbus2.SMBus(1)  # I2C bus 1
        self.address = 0x38  # AHT25のI2Cアドレス
        self.initialized = False
        
    def initialize(self) -> bool:
        """AHT25センサーを初期化"""
        try:
            # センサーリセット
            self.bus.write_byte(self.address, 0xBA)
            time.sleep(0.1)
            
            # 初期化コマンド
            self.bus.write_byte(self.address, 0xBE)
            self.bus.write_byte(self.address, 0x08)
            self.bus.write_byte(self.address, 0x00)
            time.sleep(0.1)
            
            self.initialized = True
            self.logger.info("AHT25センサー初期化完了")
            return True
            
        except Exception as e:
            self.logger.error(f"AHT25初期化エラー: {str(e)}")
            self.increment_error_count()
            return False
    
    def read_data(self) -> Dict[str, Any]:
        """温湿度データを読み取る"""
        if not self.initialized:
            if not self.initialize():
                return {"error": "初期化失敗"}
        
        try:
            # 測定開始コマンド
            self.bus.write_byte(self.address, 0xAC)
            self.bus.write_byte(self.address, 0x33)
            self.bus.write_byte(self.address, 0x00)
            
            # 測定完了待機
            time.sleep(0.1)
            
            # データ読み取り
            data = self.bus.read_i2c_block_data(self.address, 0x00, 6)
            
            # データ解析
            humidity_raw = (data[1] << 12) | (data[2] << 4) | (data[3] >> 4)
            temperature_raw = ((data[3] & 0x0F) << 16) | (data[4] << 8) | data[5]
            
            # 値に変換
            humidity = (humidity_raw / 0x100000) * 100
            temperature = (temperature_raw / 0x100000) * 200 - 50
            
            # 値の妥当性チェック
            if not (0 <= humidity <= 100) or not (-40 <= temperature <= 85):
                raise ValueError("センサー値が範囲外です")
            
            self.reset_error_count()
            return {
                "temperature": round(temperature, 1),
                "humidity": round(humidity, 1),
                "timestamp": time.time()
            }
            
        except Exception as e:
            self.logger.error(f"AHT25読み取りエラー: {str(e)}")
            self.increment_error_count()
            return {"error": str(e)}
    
    def get_status(self) -> Dict[str, Any]:
        """センサー状態を取得"""
        return {
            "name": self.name,
            "enabled": self.is_enabled,
            "error_count": self.error_count,
            "healthy": self.is_healthy(),
            "initialized": self.initialized
        }
```

#### 3.3 SEN0193土壌水分センサークラス
```python
# src/sensors/sen0193_sensor.py
import spidev
import time
import numpy as np
from typing import Dict, Any, List
from .base_sensor import BaseSensor

class SEN0193Sensor(BaseSensor):
    """SEN0193土壌水分センサー制御クラス"""
    
    def __init__(self):
        super().__init__("SEN0193", 0)
        self.spi = spidev.SpiDev()
        self.spi.open(0, 0)  # SPI bus 0, device 0
        self.spi.max_speed_hz = 1000000  # 1MHz
        self.channel = 0  # MCP3002 CH0
        self.reading_history = []
        self.max_history = 10
        
    def initialize(self) -> bool:
        """SEN0193センサーを初期化"""
        try:
            # SPI通信テスト
            test_data = self._read_adc(self.channel)
            if test_data is None:
                raise Exception("SPI通信テスト失敗")
            
            self.logger.info("SEN0193センサー初期化完了")
            return True
            
        except Exception as e:
            self.logger.error(f"SEN0193初期化エラー: {str(e)}")
            self.increment_error_count()
            return False
    
    def _read_adc(self, channel: int) -> Optional[int]:
        """ADCから値を読み取る"""
        try:
            # MCP3002用のSPI通信
            adc = self.spi.xfer2([1, (8 + channel) << 4, 0])
            data = ((adc[1] & 3) << 8) + adc[2]
            return data
        except Exception as e:
            self.logger.error(f"ADC読み取りエラー: {str(e)}")
            return None
    
    def read_data(self) -> Dict[str, Any]:
        """土壌水分データを読み取る"""
        try:
            # 複数回読み取りでノイズ除去
            readings = []
            for _ in range(5):
                value = self._read_adc(self.channel)
                if value is not None:
                    readings.append(value)
                time.sleep(0.01)
            
            if not readings:
                raise Exception("ADC読み取り失敗")
            
            # 平均値計算
            raw_value = np.mean(readings)
            
            # 履歴に追加
            self.reading_history.append(raw_value)
            if len(self.reading_history) > self.max_history:
                self.reading_history.pop(0)
            
            # 移動平均でフィルタリング
            filtered_value = np.mean(self.reading_history)
            
            # 土壌水分率に変換 (0-1023 → 0-100%)
            moisture_percentage = (filtered_value / 1023) * 100
            
            # 値の妥当性チェック
            if not (0 <= moisture_percentage <= 100):
                raise ValueError("土壌水分値が範囲外です")
            
            self.reset_error_count()
            return {
                "raw_value": int(raw_value),
                "filtered_value": int(filtered_value),
                "moisture_percentage": round(moisture_percentage, 1),
                "timestamp": time.time()
            }
            
        except Exception as e:
            self.logger.error(f"SEN0193読み取りエラー: {str(e)}")
            self.increment_error_count()
            return {"error": str(e)}
    
    def get_status(self) -> Dict[str, Any]:
        """センサー状態を取得"""
        return {
            "name": self.name,
            "enabled": self.is_enabled,
            "error_count": self.error_count,
            "healthy": self.is_healthy(),
            "reading_history_length": len(self.reading_history)
        }
```

#### 3.4 フロートスイッチクラス
```python
# src/sensors/float_switch.py
import RPi.GPIO as GPIO
import time
from typing import Dict, Any
from .base_sensor import BaseSensor

class FloatSwitch(BaseSensor):
    """フロートスイッチ制御クラス"""
    
    def __init__(self, pin: int = 18):
        super().__init__("FloatSwitch", pin)
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        
    def initialize(self) -> bool:
        """フロートスイッチを初期化"""
        try:
            # 初期状態確認
            initial_state = self.read_data()
            self.logger.info(f"フロートスイッチ初期化完了: {initial_state}")
            return True
        except Exception as e:
            self.logger.error(f"フロートスイッチ初期化エラー: {str(e)}")
            self.increment_error_count()
            return False
    
    def read_data(self) -> Dict[str, Any]:
        """フロートスイッチの状態を読み取る"""
        try:
            # デバウンス処理
            readings = []
            for _ in range(5):
                readings.append(GPIO.input(self.pin))
                time.sleep(0.01)
            
            # 多数決で状態決定
            state = 1 if sum(readings) >= 3 else 0
            is_water_available = bool(state)
            
            self.reset_error_count()
            return {
                "is_water_available": is_water_available,
                "raw_state": state,
                "timestamp": time.time()
            }
            
        except Exception as e:
            self.logger.error(f"フロートスイッチ読み取りエラー: {str(e)}")
            self.increment_error_count()
            return {"error": str(e)}
    
    def get_status(self) -> Dict[str, Any]:
        """センサー状態を取得"""
        return {
            "name": self.name,
            "enabled": self.is_enabled,
            "error_count": self.error_count,
            "healthy": self.is_healthy(),
            "pin": self.pin
        }
```

### Step 4: センサーマネージャークラス

#### 4.1 センサー管理システム
```python
# src/sensors/sensor_manager.py
import threading
import time
import logging
from typing import Dict, Any, List
from .aht25_sensor import AHT25Sensor
from .sen0193_sensor import SEN0193Sensor
from .float_switch import FloatSwitch

class SensorManager:
    """センサー管理クラス"""
    
    def __init__(self):
        self.logger = logging.getLogger("sensor_manager")
        self.sensors = {}
        self.data_cache = {}
        self.running = False
        self.threads = {}
        
        # センサー初期化
        self._initialize_sensors()
        
    def _initialize_sensors(self):
        """センサーを初期化"""
        try:
            # 温湿度センサー
            self.sensors['temperature_humidity'] = AHT25Sensor()
            
            # 土壌水分センサー
            self.sensors['soil_moisture'] = SEN0193Sensor()
            
            # フロートスイッチ
            self.sensors['water_level'] = FloatSwitch()
            
            self.logger.info("全センサー初期化完了")
            
        except Exception as e:
            self.logger.error(f"センサー初期化エラー: {str(e)}")
    
    def start_monitoring(self):
        """センサー監視開始"""
        self.running = True
        
        # 温湿度センサー監視 (30分間隔)
        self.threads['temperature_humidity'] = threading.Thread(
            target=self._monitor_temperature_humidity,
            daemon=True
        )
        self.threads['temperature_humidity'].start()
        
        # 土壌水分センサー監視 (5分間隔)
        self.threads['soil_moisture'] = threading.Thread(
            target=self._monitor_soil_moisture,
            daemon=True
        )
        self.threads['soil_moisture'].start()
        
        # フロートスイッチ監視 (1分間隔)
        self.threads['water_level'] = threading.Thread(
            target=self._monitor_water_level,
            daemon=True
        )
        self.threads['water_level'].start()
        
        self.logger.info("センサー監視開始")
    
    def stop_monitoring(self):
        """センサー監視停止"""
        self.running = False
        self.logger.info("センサー監視停止")
    
    def _monitor_temperature_humidity(self):
        """温湿度センサー監視"""
        while self.running:
            try:
                data = self.sensors['temperature_humidity'].read_data()
                if 'error' not in data:
                    self.data_cache['temperature_humidity'] = data
                    self.logger.debug(f"温湿度データ更新: {data}")
                else:
                    self.logger.error(f"温湿度センサーエラー: {data['error']}")
                
                time.sleep(1800)  # 30分待機
                
            except Exception as e:
                self.logger.error(f"温湿度監視エラー: {str(e)}")
                time.sleep(60)  # エラー時は1分待機
    
    def _monitor_soil_moisture(self):
        """土壌水分センサー監視"""
        while self.running:
            try:
                data = self.sensors['soil_moisture'].read_data()
                if 'error' not in data:
                    self.data_cache['soil_moisture'] = data
                    self.logger.debug(f"土壌水分データ更新: {data}")
                else:
                    self.logger.error(f"土壌水分センサーエラー: {data['error']}")
                
                time.sleep(300)  # 5分待機
                
            except Exception as e:
                self.logger.error(f"土壌水分監視エラー: {str(e)}")
                time.sleep(60)  # エラー時は1分待機
    
    def _monitor_water_level(self):
        """フロートスイッチ監視"""
        while self.running:
            try:
                data = self.sensors['water_level'].read_data()
                if 'error' not in data:
                    self.data_cache['water_level'] = data
                    self.logger.debug(f"水位データ更新: {data}")
                else:
                    self.logger.error(f"フロートスイッチエラー: {data['error']}")
                
                time.sleep(60)  # 1分待機
                
            except Exception as e:
                self.logger.error(f"水位監視エラー: {str(e)}")
                time.sleep(30)  # エラー時は30秒待機
    
    def get_latest_data(self, sensor_name: str = None) -> Dict[str, Any]:
        """最新のセンサーデータを取得"""
        if sensor_name:
            return self.data_cache.get(sensor_name, {})
        return self.data_cache.copy()
    
    def get_sensor_status(self) -> Dict[str, Any]:
        """全センサーの状態を取得"""
        status = {}
        for name, sensor in self.sensors.items():
            status[name] = sensor.get_status()
        return status
    
    def force_read(self, sensor_name: str) -> Dict[str, Any]:
        """指定センサーの強制読み取り"""
        if sensor_name in self.sensors:
            return self.sensors[sensor_name].read_data()
        return {"error": "センサーが見つかりません"}
```

### Step 5: テスト実装

#### 5.1 センサーテストスクリプト
```python
# test_sensors.py
import time
import logging
from src.sensors.sensor_manager import SensorManager

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

def test_sensors():
    """センサーテスト実行"""
    print("🌱 センサーテスト開始")
    
    # センサーマネージャー初期化
    sensor_manager = SensorManager()
    
    # 個別センサーテスト
    print("\n📊 個別センサーテスト")
    
    # 温湿度センサーテスト
    print("🌡️ 温湿度センサーテスト...")
    temp_humidity_data = sensor_manager.force_read('temperature_humidity')
    print(f"結果: {temp_humidity_data}")
    
    # 土壌水分センサーテスト
    print("💧 土壌水分センサーテスト...")
    soil_moisture_data = sensor_manager.force_read('soil_moisture')
    print(f"結果: {soil_moisture_data}")
    
    # フロートスイッチテスト
    print("🚰 フロートスイッチテスト...")
    water_level_data = sensor_manager.force_read('water_level')
    print(f"結果: {water_level_data}")
    
    # センサー状態確認
    print("\n📋 センサー状態")
    status = sensor_manager.get_sensor_status()
    for name, sensor_status in status.items():
        print(f"{name}: {sensor_status}")
    
    # 監視テスト (30秒間)
    print("\n🔄 監視テスト (30秒間)")
    sensor_manager.start_monitoring()
    
    for i in range(6):
        time.sleep(5)
        latest_data = sensor_manager.get_latest_data()
        print(f"5秒後: {latest_data}")
    
    sensor_manager.stop_monitoring()
    print("✅ センサーテスト完了")

if __name__ == "__main__":
    test_sensors()
```

### Step 6: トラブルシューティング

#### 6.1 よくある問題と解決方法

**I2C通信エラー:**
```bash
# I2Cデバイス確認
sudo i2cdetect -y 1

# 期待される出力: 0x38 (AHT25のアドレス)
```

**SPI通信エラー:**
```bash
# SPIデバイス確認
ls /dev/spi*

# 期待される出力: /dev/spidev0.0
```

**GPIO権限エラー:**
```bash
# GPIOグループに追加
sudo usermod -a -G gpio pi

# 再ログインが必要
```

#### 6.2 デバッグ用コマンド
```bash
# センサーテスト実行
cd /home/pi/smart-planter
python test_sensors.py

# ログ確認
tail -f /var/log/syslog | grep sensor

# GPIO状態確認
gpio readall
```

---

## 📊 実装完了チェックリスト

- [ ] ハードウェア接続完了
- [ ] I2C・SPI有効化完了
- [ ] 必要なライブラリインストール完了
- [ ] 基本センサークラス実装完了
- [ ] AHT25センサークラス実装完了
- [ ] SEN0193センサークラス実装完了
- [ ] フロートスイッチクラス実装完了
- [ ] センサーマネージャークラス実装完了
- [ ] テストスクリプト実行完了
- [ ] エラーハンドリング確認完了
- [ ] ログ出力確認完了

---

## 🎯 次のステップ

1. **自動給水機能実装**: センサーデータに基づく給水制御
2. **データ保存機能**: CSV形式でのデータ保存
3. **LINE通知統合**: センサー異常時の通知
4. **Web UI統合**: リアルタイムデータ表示

---

**作成日**: 2025年1月
**バージョン**: 1.0
**チーム**: KEBABS

